1.原型链
通过创建SuperType的实例，并将该实例赋给SubType.prototype实现的， 本质是重写原型对象，代之以一个新类型的实例
问题：包含引用类型值的原型属性会被所有实例共享

2.借用构造函数
思想：在子类型构造函数里面调用超类型的构造函数
function SubType() {
    SuperType.call(this);
}
问题：每个子类实例都会拷贝一份父类构造函数中的方法，占用内存大。方法都在超类型中定义，函数复用无从谈起，而且，在超类型中
定义的方法，对于子类型而言也是不可见的（私有方法，私有化属性和方法的作用是保护属性或方法不被随意重写/覆盖）

3.组合继承（原型链+构造函数）
用构造函数方式继承属性，原型链方式继承方法

4.原型式继承

5.寄生式继承

6.寄生组合式继承